@using System;
@using Sandbox;
@using Sandbox.UI;
@namespace Punt.UI
@inherits PanelComponent

<root class="aim-indicator @(IsVisible ? "visible" : "hidden") @(IsInverted ? "inverted" : "")">
    <div class="aim-line">
        @if (IsInverted)
        {
            <div class="aim-head aim-block" style="@GetBackgroundStyle(HeadImage)"></div>
            <div class="aim-body aim-block" style="@GetBackgroundStyle(BodyImage)"></div>
            <div class="aim-tail aim-block" style="@GetBackgroundStyle(TailImage)"></div>
        }
        else
        {
            <div class="aim-tail aim-block" style="@GetBackgroundStyle(TailImage)"></div>
            <div class="aim-body aim-block" style="@GetBackgroundStyle(BodyImage)"></div>
            <div class="aim-head aim-block" style="@GetBackgroundStyle(HeadImage)"></div>
        }
    </div>
</root>

@code
{
    /// <summary>
    /// Reference to the WorldPanel component that hosts this panel
    /// </summary>
    [Property] public Sandbox.WorldPanel WorldPanel { get; set; }

    /// <summary>
    /// Start position of the aim line (world space)
    /// </summary>
    [Property] public Vector3 StartPosition { get; set; }

    /// <summary>
    /// End position of the aim line (world space)
    /// </summary>
    [Property] public Vector3 EndPosition { get; set; }

    /// <summary>
    /// Is the indicator currently visible?
    /// </summary>
    [Property] public bool IsVisible { get; set; }

    /// <summary>
    /// When true, the indicator shows trajectory (head at end, pointing away from piece).
    /// When false, the indicator shows pull direction (tail at end, pointing toward piece).
    /// </summary>
    [Property] public bool IsInverted { get; set; }

    /// <summary>
    /// Fixed width (perpendicular to the line direction)
    /// </summary>
    [Property] public float Width { get; set; } = 2000f;

    /// <summary>
    /// Distance to offset the start of the line away from the piece center (in world units)
    /// </summary>
    [Property] public float StartOffset { get; set; } = 30f;

    /// <summary>
    /// Optional image path for the head block
    /// </summary>
    [Property] public string HeadImage { get; set; }

    /// <summary>
    /// Optional image path for the tail block
    /// </summary>
    [Property] public string TailImage { get; set; }

    /// <summary>
    /// Optional image path for the body block
    /// </summary>
    [Property] public string BodyImage { get; set; }

    private string GetBackgroundStyle(string imagePath)
    {
        if (string.IsNullOrWhiteSpace(imagePath))
            return null;

        return $"background-image: url('{imagePath}');";
    }

    protected override void OnStart()
    {
        base.OnStart();

        // Auto-find the WorldPanel component if not manually set
        if (WorldPanel == null)
        {
            WorldPanel = GameObject.Components.Get<Sandbox.WorldPanel>();
        }
    }

    protected override void OnUpdate()
    {
        base.OnUpdate();

        if (!IsVisible || WorldPanel == null)
            return;

        // Calculate direction and distance (work in 2D on the pitch)
        Vector3 direction = (EndPosition - StartPosition).WithZ(0);
        float distance = direction.Length;

        if (distance < 0.1f)
            return;

        // Apply start offset - move the start position along the direction vector
        Vector3 directionNormalized = direction.Normal;
        Vector3 offsetStartPosition = StartPosition + (directionNormalized * StartOffset);

        // Recalculate distance after offset
        Vector3 offsetDirection = (EndPosition - offsetStartPosition).WithZ(0);
        float offsetDistance = offsetDirection.Length;

        if (offsetDistance < 0.1f)
            return;

        // Position the panel at the midpoint between offset start and cursor
        Vector3 midpoint = offsetStartPosition + (offsetDirection / 2);
        WorldPanel.GameObject.WorldPosition = midpoint;

        // Calculate rotation - the line should point from start to end
        float angleRadians = MathF.Atan2(offsetDirection.y, offsetDirection.x);
        float angleDegrees = angleRadians * (180f / MathF.PI);

        // Set the rotation - combine the panel's default 90° pitch with the calculated yaw
        WorldPanel.GameObject.WorldRotation = Rotation.From(90, angleDegrees, 0);

        // Update the panel size - use the offset distance
        var panelSize = new Vector2(Width, offsetDistance * 20f);
        WorldPanel.PanelSize = panelSize;

        StateHasChanged();
    }

    protected override int BuildHash()
    {
        return HashCode.Combine(IsVisible, StartPosition, EndPosition, IsInverted);
    }
}
