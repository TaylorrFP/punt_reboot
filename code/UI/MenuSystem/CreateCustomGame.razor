@using System
@using Sandbox.Menu
@using Sandbox.UI;
@using Sandbox.UI.Navigation;
@using Sandbox.Network;
@using Sandbox.Modals;


@inherits Panel
@implements INavigatorPage
@namespace Punt.UI

<root class="main-menu create-custom-games-page @(IsDragging ? "is-dragging" : "")">
    <page-header>Create Game</page-header>

    <div class="content-panels">
        <div class="buttons-panel">

            <div class="button" onclick="@OnAddFriendClicked">
                <i>person_add_alt</i>
                <span>Add Friend</span>
            </div>

            <div class="button" onclick="@OnAddFriendClicked">
                <i>sports_esports</i>
                <span>Add Local Player</span>
            </div>


            <div class="button">
                <i>smart_toy</i>
                <span>Add Bot</span>
            </div>

            <div class="button">
                <i>settings</i>
                <span>Settings</span>
            </div>


        </div>
        <div class="main-content">
            <div class="game-panel panel">
                <div class="header-image-panel" style="background-image: url('ui/mainmenu/mapheaders/testmap_header.png');">
                    <div class="pitch-name">Test Map</div>
                </div>
                <div class="lobby-config-panel">
                    <div class="lobby-name-input @(IsInLobby ? "disabled" : "")">
                        <TextEntry @ref="LobbyNameInput" Text="@DisplayedLobbyName" Placeholder="Lobby Name" />
                    </div>

                    <div class="lobby-setting @(IsInLobby ? "disabled" : "")">
                        <span class="setting-label">Max Players</span>
                        <DropDown @ref="MaxPlayersDropdown" Options=@MaxPlayersOptions Value=@("4") />
                    </div>

                    <div class="lobby-setting @(IsInLobby ? "disabled" : "")">
                        <span class="setting-label">Privacy</span>
                        <DropDown @ref="PrivacyDropdown" Options=@PrivacyOptions Value=@("Public") />
                    </div>



                    <div class="create-lobby-button-container">
                        @if (IsInLobby && Networking.IsHost)
                        {
                            <div class="create-lobby-button start-game" onclick="@OnStartGameClicked">
                                Start Game
                            </div>
                        }
                        else if (!IsInLobby)
                        {
                            <div class="create-lobby-button" onclick="@OnCreateLobbyClicked">
                                Create Lobby
                            </div>
                        }
                    </div>
                </div>
            </div>
            <div class="right-column">
                <div class="team-settings-panel panel">
                    <div class="teams-panel">
                        <div class="team-panel red" @ref="RedTeamPanel">
                            <div class="panel-header">Red Team</div>
                            <div class="team-slots">
                                @for (int i = 0; i < RedTeamSlots.Length; i++)
                                {
                                    var slot = RedTeamSlots[i];
                                    var index = i;
                                    @if (slot.IsOccupied)
                                    {
                                        <div class="player-slot occupied team-red @(slot.IsBeingDragged ? "being-dragged" : "")" onmousedown="@(() => OnSlotMouseDown(Team.Red, index))">
                                            <img src="avatar:@slot.SteamId" class="profile-picture" />
                                            <span class="player-name">@slot.DisplayName</span>
                                        </div>
                                    }
                                    else
                                    {
                                        <div class="player-slot empty @(HighlightedTeam == Team.Red && HighlightedIndex == index ? "drop-target" : "")">Empty</div>
                                    }
                                }
                            </div>
                        </div>
                        <div class="vs-panel">
                            VS
                        </div>
                        <div class="team-panel blue" @ref="BlueTeamPanel">
                            <div class="panel-header">Blue Team</div>
                            <div class="team-slots">
                                @for (int i = 0; i < BlueTeamSlots.Length; i++)
                                {
                                    var slot = BlueTeamSlots[i];
                                    var index = i;
                                    @if (slot.IsOccupied)
                                    {
                                        <div class="player-slot occupied team-blue @(slot.IsBeingDragged ? "being-dragged" : "")" onmousedown="@(() => OnSlotMouseDown(Team.Blue, index))">
                                            <img src="avatar:@slot.SteamId" class="profile-picture" />
                                            <span class="player-name">@slot.DisplayName</span>
                                        </div>
                                    }
                                    else
                                    {
                                        <div class="player-slot empty @(HighlightedTeam == Team.Blue && HighlightedIndex == index ? "drop-target" : "")">Empty</div>
                                    }
                                }
                            </div>
                        </div>
                    </div>
                </div>
                <div class="spectators-panel panel" @ref="SpectatorPanel">
                    <div class="panel-header">Spectators</div>
                    <div class="spectator-slots">
                        @for (int i = 0; i < SpectatorSlots.Length; i++)
                        {
                            var slot = SpectatorSlots[i];
                            var index = i;
                            @if (slot.IsOccupied)
                            {
                                <div class="player-slot occupied team-spectator @(slot.IsBeingDragged ? "being-dragged" : "")" onmousedown="@(() => OnSlotMouseDown(Team.Spectator, index))">
                                    <img src="avatar:@slot.SteamId" class="profile-picture" />
                                    <span class="player-name">@slot.DisplayName</span>
                                </div>
                            }
                            else
                            {
                                <div class="player-slot empty @(HighlightedTeam == Team.Spectator && HighlightedIndex == index ? "drop-target" : "")">Empty</div>
                            }
                        }
                    </div>
                </div>
            </div>
        </div>
    </div>

    @if (IsDragging)
    {
        <div class="dragged-player @GetDraggedTeamClass()" @ref="DraggedElement">
            <img src="avatar:@DraggedSteamId" class="profile-picture" />
            <span class="player-name">@DraggedDisplayName</span>
        </div>
    }
</root>

@code
{
    // ===================================================================================
    // LOBBY CONFIGURATION
    // ===================================================================================

    private TextEntry LobbyNameInput;
    private DropDown PrivacyDropdown;
    private DropDown MaxPlayersDropdown;
    private string DefaultLobbyName => $"{Connection.Local?.DisplayName ?? "Player"}'s Game";
    private bool IsInLobby => GameSession.Instance?.State == SessionState.CustomLobby;
    private string DisplayedLobbyName => IsInLobby ? GameSession.Instance?.LobbyName ?? DefaultLobbyName : DefaultLobbyName;

    private static List<Option> PrivacyOptions => new()
    {
        new Option( "Public", "Public" ),
        new Option( "Friends Only", "Friends Only" ),
        new Option( "Private", "Private" )
    };

    private static List<Option> MaxPlayersOptions => new()
    {
        new Option( "2", "2" ),
        new Option( "3", "3" ),
        new Option( "4", "4" ),
        new Option( "5", "5" ),
        new Option( "6", "6" ),
        new Option( "7", "7" ),
        new Option( "8", "8" ),
        new Option( "9", "9" ),
        new Option( "10", "10" ),
        new Option( "11", "11" ),
        new Option( "12", "12" )

    };

    private void OnAddFriendClicked()
    {

        var opts = new FriendsListModalOptions();

      


        Game.Overlay.ShowFriendsList( new FriendsListModalOptions() );
    }

    private void OnCreateLobbyClicked()
    {
        // Check if in a party and not the leader
        if (PartyRoom.Current != null && PartyRoom.Current.Owner.Id != Game.SteamId)
        {
            NotificationPanel.Show("Only the party leader can create a lobby",0.75f);
            return;
        }

        var lobbyName = LobbyNameInput?.Text ?? DefaultLobbyName;
        var maxPlayers = int.Parse( MaxPlayersDropdown?.Selected?.Value?.ToString() ?? "4" );
        var privacyValue = PrivacyDropdown?.Selected?.Value?.ToString() ?? "Public";

        var privacy = privacyValue switch
        {
            "Friends Only" => LobbyPrivacy.FriendsOnly,
            "Private" => LobbyPrivacy.Private,
            _ => LobbyPrivacy.Public
        };

        NetworkManager.Instance?.CreateLobby( maxPlayers, privacy, lobbyName );

        // Refresh lobby members after creating the lobby
        RefreshLobbyMembers();
    }

    private void OnStartGameClicked()
    {
        var session = GameSession.Instance;
        if (session == null) return;

        int redCount = session.GetTeamCount(TeamSide.Red);
        int blueCount = session.GetTeamCount(TeamSide.Blue);

        // Warn if either team is empty
        if (redCount == 0 || blueCount == 0)
        {
            ConfirmationDialog.Show(
                "Not all teams have players. Start Anyway?",
                "Yes",
                "Cancel",
                () => NetworkManager.Instance?.StartGame()
            );
            return;
        }

        NetworkManager.Instance?.StartGame();
    }

    // ===================================================================================
    // DRAG-AND-DROP PLAYER SLOT SYSTEM
    // ===================================================================================
    //
    // OVERVIEW:
    // Players can be dragged between team slots (Red, Blue, Spectator). Click-hold to
    // pick up a player, drag to a team panel, release to drop into first available slot.
    //
    // KEY DESIGN DECISIONS:
    //
    // 1. SOURCE SLOT STAYS IN DOM (Critical!)
    //    When dragging starts, we DON'T hide the source element. Instead, we mark it with
    //    IsBeingDragged=true and use CSS (.being-dragged) to make it LOOK empty while
    //    keeping it in the DOM. This is essential because removing/hiding the element
    //    that received mousedown breaks the mouse event chain - OnMouseUp would never fire.
    //
    // 2. DROP TARGETS ARE TEAM PANELS, NOT INDIVIDUAL SLOTS
    //    We hit-test against the team panel (@ref="RedTeamPanel" etc), not individual slots.
    //    When dropping on a team, we find the first available slot automatically.
    //    This simplifies the UX - just drag to the team area, don't need pixel-perfect aim.
    //
    // 3. SLOT COMPACTION
    //    After each drop, CompactSlots() shifts all players to fill from index 0.
    //    This prevents gaps (e.g., if you drag out of slot 0, slot 1 becomes slot 0).
    //
    // 4. SOURCE SLOT TREATED AS AVAILABLE
    //    When finding drop targets, FindFirstAvailableSlot() treats the source slot as
    //    empty. This means dragging within the same team targets the source position,
    //    effectively a no-op (player stays in same spot).
    //
    // DRAG FLOW:
    // 1. OnSlotMouseDown: User clicks occupied slot -> IsDragging=true, slot.IsBeingDragged=true
    // 2. Tick: Every frame updates drag position and highlights target slot
    // 3. OnMouseUp: User releases -> EndDrag() moves player data to target, compacts slots
    //
    // VISUAL FEEDBACK:
    // - Source slot: Shows "Empty" via CSS ::after (hides avatar/name with display:none)
    // - Target slot: Gets "drop-target" class for highlight styling
    // - Dragged element: Floating div that follows cursor (transformed to panel coordinates)
    // ===================================================================================

    public enum Team { Red, Blue, Spectator }

    public class PlayerSlot
    {
        public bool IsOccupied { get; set; }
        public Guid ConnectionId { get; set; }  // Used for team assignment lookups
        public long SteamId { get; set; }       // Used for avatar display
        public string DisplayName { get; set; }
        public bool IsBeingDragged { get; set; }
    }

    // Slot data - initialize with empty PlayerSlot objects immediately
    private PlayerSlot[] RedTeamSlots = CreateEmptySlots(5);
    private PlayerSlot[] BlueTeamSlots = CreateEmptySlots(5);
    private PlayerSlot[] SpectatorSlots = CreateEmptySlots(2);
    private bool SlotsInitialized = false;

    // Panel references for hit-testing (team panels, not individual slots)
    private Panel RedTeamPanel;
    private Panel BlueTeamPanel;
    private Panel SpectatorPanel;

    // Drag state
    private bool IsDragging = false;
    private Team DragSourceTeam;
    private int DragSourceIndex;
    private Guid DraggedConnectionId;
    private long DraggedSteamId;
    private string DraggedDisplayName;
    private Vector2 DragPosition;
    private Panel DraggedElement;

    // Drop target highlighting
    private Team? HighlightedTeam = null;
    private int? HighlightedIndex = null;

    private static PlayerSlot[] CreateEmptySlots(int count)
    {
        var slots = new PlayerSlot[count];
        for (int i = 0; i < count; i++)
        {
            slots[i] = new PlayerSlot();
        }
        return slots;
    }

    protected override void OnAfterTreeRender(bool firstTime)
    {
        base.OnAfterTreeRender(firstTime);

        if (firstTime)
        {
            if (GameSession.Instance != null)
            {
                GameSession.Instance.OnStateChanged += OnSessionStateChanged;
            }
        }

        if (!SlotsInitialized)
        {
            InitializeSlots();
            SlotsInitialized = true;
        }

        UpdateDraggedElementPosition();
    }

    public void OnNavigationOpen()
    {
        // Refresh lobby members when opening this page if already in a lobby
        if (IsInLobby)
        {
            RefreshLobbyMembers();
        }
    }

    public void OnNavigationClose()
    {
        // Unsubscribe from events when leaving this page
        if (GameSession.Instance != null)
        {
            GameSession.Instance.OnStateChanged -= OnSessionStateChanged;
        }
    }

    private void OnSessionStateChanged( SessionState oldState, SessionState newState )
    {
        // BuildHash will handle the rebuild automatically
    }

    private void InitializeSlots()
    {
        //Log.Info("[DragDrop] InitializeSlots called");
        RefreshLobbyMembers();
    }

    private void RefreshLobbyMembers()
    {
        // Clear all slots first
        foreach (var slot in RedTeamSlots) { slot.IsOccupied = false; slot.ConnectionId = Guid.Empty; slot.SteamId = 0; slot.DisplayName = null; }
        foreach (var slot in BlueTeamSlots) { slot.IsOccupied = false; slot.ConnectionId = Guid.Empty; slot.SteamId = 0; slot.DisplayName = null; }
        foreach (var slot in SpectatorSlots) { slot.IsOccupied = false; slot.ConnectionId = Guid.Empty; slot.SteamId = 0; slot.DisplayName = null; }

        var teamAssignments = GameSession.Instance?.TeamAssignments;
        if (teamAssignments == null || teamAssignments.Count == 0)
            return;

        // Track slot indices for each team
        int redIndex = 0, blueIndex = 0, spectatorIndex = 0;

        foreach (var kvp in teamAssignments)
        {
            var connectionId = kvp.Key;
            var team = kvp.Value;

            // Find the connection to get display name and SteamId
            var connection = Connection.All.FirstOrDefault(c => c.Id == connectionId);
            var displayName = connection?.DisplayName ?? $"Player {connectionId}";
            var steamId = connection?.SteamId ?? 0L;

            switch (team)
            {
                case TeamSide.Red:
                    if (redIndex < RedTeamSlots.Length)
                    {
                        RedTeamSlots[redIndex].IsOccupied = true;
                        RedTeamSlots[redIndex].ConnectionId = connectionId;
                        RedTeamSlots[redIndex].SteamId = steamId;
                        RedTeamSlots[redIndex].DisplayName = displayName;
                        redIndex++;
                    }
                    break;

                case TeamSide.Blue:
                    if (blueIndex < BlueTeamSlots.Length)
                    {
                        BlueTeamSlots[blueIndex].IsOccupied = true;
                        BlueTeamSlots[blueIndex].ConnectionId = connectionId;
                        BlueTeamSlots[blueIndex].SteamId = steamId;
                        BlueTeamSlots[blueIndex].DisplayName = displayName;
                        blueIndex++;
                    }
                    break;

                case TeamSide.Spectator:
                    if (spectatorIndex < SpectatorSlots.Length)
                    {
                        SpectatorSlots[spectatorIndex].IsOccupied = true;
                        SpectatorSlots[spectatorIndex].ConnectionId = connectionId;
                        SpectatorSlots[spectatorIndex].SteamId = steamId;
                        SpectatorSlots[spectatorIndex].DisplayName = displayName;
                        spectatorIndex++;
                    }
                    break;
            }
        }
    }

    private void OnSlotMouseDown(Team team, int index)
    {
       //Log.Info($"[DragDrop] OnSlotMouseDown called - Team: {team}, Index: {index}");

        var slot = GetSlot(team, index);
        if (slot == null)
        {
            //Log.Info("[DragDrop] Slot is null!");
            return;
        }
        if (!slot.IsOccupied)
        {
            //Log.Info("[DragDrop] Slot is not occupied!");
            return;
        }

        //Log.Info($"[DragDrop] Starting drag for player: {slot.DisplayName}");

        // Start dragging
        IsDragging = true;
        DragSourceTeam = team;
        DragSourceIndex = index;
        DraggedConnectionId = slot.ConnectionId;
        DraggedSteamId = slot.SteamId;
        DraggedDisplayName = slot.DisplayName;
        DragPosition = Mouse.Position;

        // Mark source slot as being dragged (shows as empty)
        slot.IsBeingDragged = true;

        //Log.Info("[DragDrop] Drag started");
    }



    public override void Tick()
    {
        base.Tick();

        if (IsDragging)
        {
            // Continuously update position while dragging
            DragPosition = Mouse.Position;
            UpdateDraggedElementPosition();

            // Update drop target highlighting
            var targetTeam = FindTeamUnderMouse();
            var targetIndex = targetTeam.HasValue ? FindFirstAvailableSlot(targetTeam.Value) : null;

            if (HighlightedTeam != targetTeam || HighlightedIndex != targetIndex)
            {
                HighlightedTeam = targetTeam;
                HighlightedIndex = targetIndex;
            }
        }
    }

    protected override void OnMouseUp(MousePanelEvent e)
    {
        base.OnMouseUp(e);

        if (IsDragging)
        {
            //Log.Info("[DragDrop] Mouse released - ending drag");
            EndDrag();
        }
    }

    private void EndDrag()
    {
        var sourceSlot = GetSlot(DragSourceTeam, DragSourceIndex);

        // Find which team panel we're dropping on
        var targetTeam = FindTeamUnderMouse();

        if (targetTeam.HasValue && targetTeam.Value != DragSourceTeam)
        {
            // Convert UI Team enum to TeamSide enum
            var targetTeamSide = targetTeam.Value switch
            {
                Team.Red => TeamSide.Red,
                Team.Blue => TeamSide.Blue,
                Team.Spectator => TeamSide.Spectator,
                _ => TeamSide.None
            };

            // Update GameSession - this will sync to all clients
            GameSession.Instance?.AssignTeam(DraggedConnectionId, targetTeamSide);
        }

        // Always clear the dragging state on source
        if (sourceSlot != null)
        {
            sourceSlot.IsBeingDragged = false;
        }

        // Compact all team slots so they fill from the top
        CompactSlots(RedTeamSlots);
        CompactSlots(BlueTeamSlots);
        CompactSlots(SpectatorSlots);

        IsDragging = false;
        HighlightedTeam = null;
        HighlightedIndex = null;
    }

    private Team? FindTeamUnderMouse()
    {
        Vector2 mousePos = Mouse.Position;

        if (IsMouseOverPanel(RedTeamPanel, mousePos))
            return Team.Red;

        if (IsMouseOverPanel(BlueTeamPanel, mousePos))
            return Team.Blue;

        if (IsMouseOverPanel(SpectatorPanel, mousePos))
            return Team.Spectator;

        return null;
    }

    private int? FindFirstAvailableSlot(Team team)
    {
        var slots = team switch
        {
            Team.Red => RedTeamSlots,
            Team.Blue => BlueTeamSlots,
            Team.Spectator => SpectatorSlots,
            _ => null
        };

        if (slots == null) return null;

        for (int i = 0; i < slots.Length; i++)
        {
            // Treat slot as available if it's empty OR if it's the source slot being dragged
            bool isSourceSlot = IsDragging && team == DragSourceTeam && i == DragSourceIndex;
            if (!slots[i].IsOccupied || isSourceSlot)
                return i;
        }

        return null; // No available slots
    }

    private void CompactSlots(PlayerSlot[] slots)
    {
        // Move all occupied slots to the front, maintaining order
        int writeIndex = 0;
        for (int readIndex = 0; readIndex < slots.Length; readIndex++)
        {
            if (slots[readIndex].IsOccupied)
            {
                if (writeIndex != readIndex)
                {
                    // Move this slot to the write position
                    slots[writeIndex].IsOccupied = true;
                    slots[writeIndex].ConnectionId = slots[readIndex].ConnectionId;
                    slots[writeIndex].SteamId = slots[readIndex].SteamId;
                    slots[writeIndex].DisplayName = slots[readIndex].DisplayName;
                    slots[writeIndex].IsBeingDragged = slots[readIndex].IsBeingDragged;

                    // Clear the old position
                    slots[readIndex].IsOccupied = false;
                    slots[readIndex].ConnectionId = Guid.Empty;
                    slots[readIndex].SteamId = 0;
                    slots[readIndex].DisplayName = null;
                    slots[readIndex].IsBeingDragged = false;
                }
                writeIndex++;
            }
        }
    }

    private bool IsMouseOverPanel(Panel panel, Vector2 mousePos)
    {
        if (panel == null) return false;

        var rect = panel.Box.Rect;
        return mousePos.x >= rect.Left && mousePos.x <= rect.Right &&
               mousePos.y >= rect.Top && mousePos.y <= rect.Bottom;
    }

    private void UpdateDraggedElementPosition()
    {
        if (DraggedElement == null || !IsDragging) return;

        // Convert screen position to panel space
        Vector2 panelPosition = ScaleFromScreen * DragPosition;

        DraggedElement.Style.Left = Length.Pixels(panelPosition.x);
        DraggedElement.Style.Top = Length.Pixels(panelPosition.y);
    }

    private PlayerSlot GetSlot(Team team, int index)
    {
        return team switch
        {
            Team.Red => index < RedTeamSlots.Length ? RedTeamSlots[index] : null,
            Team.Blue => index < BlueTeamSlots.Length ? BlueTeamSlots[index] : null,
            Team.Spectator => index < SpectatorSlots.Length ? SpectatorSlots[index] : null,
            _ => null
        };
    }

    private string GetDraggedTeamClass()
    {
        return DragSourceTeam switch
        {
            Team.Red => "team-red",
            Team.Blue => "team-blue",
            Team.Spectator => "team-spectator",
            _ => ""
        };
    }

    protected override int BuildHash()
    {
        // Hash team assignments from GameSession
        var teamAssignments = GameSession.Instance?.TeamAssignments;
        int teamHash = 0;
        if (teamAssignments != null)
        {
            foreach (var kvp in teamAssignments)
            {
                teamHash = System.HashCode.Combine(teamHash, kvp.Key, kvp.Value);
            }
        }

        // Rebuild local slots from GameSession data when hash changes
        RefreshLobbyMembers();

        return System.HashCode.Combine(
            base.BuildHash(),
            IsDragging,
            DragPosition,
            HighlightedTeam,
            HighlightedIndex,
            IsInLobby,
            Networking.IsHost,
            System.HashCode.Combine(teamHash, DisplayedLobbyName)
        );
    }
}
