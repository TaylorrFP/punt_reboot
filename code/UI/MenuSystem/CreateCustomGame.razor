@using Sandbox.Menu
@using Sandbox.UI;
@using Sandbox.UI.Navigation;
@using Sandbox.Network;
@using Sandbox.Modals;


@inherits Panel
@implements INavigatorPage
@namespace Punt.UI

<root class="main-menu create-custom-games-page">
    <page-header>Create Game</page-header>

    <div class="content-panels">
        <div class="buttons-panel">

            <div class="button" onclick="@OnAddFriendClicked">
                <i>person_add_alt</i>
                <span>Add Friend</span>
            </div>

            <div class="button">
                <i>settings</i>
                <span>Settings</span>
            </div>
            <div class="button">
                <i>smart_toy</i>
                <span>Add Bot</span>
            </div>
        </div>
        <div class="main-content">
            <div class="game-panel panel">
                <div class="header-image-panel" style="background-image: url('ui/mainmenu/mapheaders/testmap_header.png');">
                    <div class="pitch-name">Test Map</div>
                </div>
                <div class="lobby-config-panel">
                    <div class="lobby-name-input @(IsInLobby ? "disabled" : "")">
                        <TextEntry @ref="LobbyNameInput" Text="@DefaultLobbyName" Placeholder="Lobby Name" />
                    </div>

                    <div class="lobby-setting @(IsInLobby ? "disabled" : "")">
                        <span class="setting-label">Privacy</span>
                        <DropDown @ref="PrivacyDropdown" Options=@PrivacyOptions Value=@("Public") />
                    </div>

                    <div class="lobby-setting @(IsInLobby ? "disabled" : "")">
                        <span class="setting-label">Max Players</span>
                        <DropDown @ref="MaxPlayersDropdown" Options=@MaxPlayersOptions Value=@("4") />
                    </div>

                    <div class="create-lobby-button-container">
                        @if (IsInLobby)
                        {
                            <div class="create-lobby-button start-game" onclick="@OnStartGameClicked">
                                Start Game
                            </div>
                        }
                        else
                        {
                            <div class="create-lobby-button" onclick="@OnCreateLobbyClicked">
                                Create Lobby
                            </div>
                        }
                    </div>
                </div>
            </div>
            <div class="right-column">
                <div class="team-settings-panel panel">
                    <div class="teams-panel">
                        <div class="team-panel red" @ref="RedTeamPanel">
                            <div class="panel-header">Red Team</div>
                            <div class="team-slots">
                                @for (int i = 0; i < RedTeamSlots.Length; i++)
                                {
                                    var slot = RedTeamSlots[i];
                                    var index = i;
                                    @if (slot.IsOccupied)
                                    {
                                        <div class="player-slot occupied team-red @(slot.IsBeingDragged ? "being-dragged" : "")" onmousedown="@(() => OnSlotMouseDown(Team.Red, index))">
                                            <img src="avatar:@slot.SteamId" class="profile-picture" />
                                            <span class="player-name">@slot.DisplayName</span>
                                        </div>
                                    }
                                    else
                                    {
                                        <div class="player-slot empty @(HighlightedTeam == Team.Red && HighlightedIndex == index ? "drop-target" : "")">Empty</div>
                                    }
                                }
                            </div>
                        </div>
                        <div class="vs-panel">
                            VS
                        </div>
                        <div class="team-panel blue" @ref="BlueTeamPanel">
                            <div class="panel-header">Blue Team</div>
                            <div class="team-slots">
                                @for (int i = 0; i < BlueTeamSlots.Length; i++)
                                {
                                    var slot = BlueTeamSlots[i];
                                    var index = i;
                                    @if (slot.IsOccupied)
                                    {
                                        <div class="player-slot occupied team-blue @(slot.IsBeingDragged ? "being-dragged" : "")" onmousedown="@(() => OnSlotMouseDown(Team.Blue, index))">
                                            <img src="avatar:@slot.SteamId" class="profile-picture" />
                                            <span class="player-name">@slot.DisplayName</span>
                                        </div>
                                    }
                                    else
                                    {
                                        <div class="player-slot empty @(HighlightedTeam == Team.Blue && HighlightedIndex == index ? "drop-target" : "")">Empty</div>
                                    }
                                }
                            </div>
                        </div>
                    </div>
                </div>
                <div class="spectators-panel panel" @ref="SpectatorPanel">
                    <div class="panel-header">Spectators</div>
                    <div class="spectator-slots">
                        @for (int i = 0; i < SpectatorSlots.Length; i++)
                        {
                            var slot = SpectatorSlots[i];
                            var index = i;
                            @if (slot.IsOccupied)
                            {
                                <div class="player-slot occupied team-spectator @(slot.IsBeingDragged ? "being-dragged" : "")" onmousedown="@(() => OnSlotMouseDown(Team.Spectator, index))">
                                    <img src="avatar:@slot.SteamId" class="profile-picture" />
                                    <span class="player-name">@slot.DisplayName</span>
                                </div>
                            }
                            else
                            {
                                <div class="player-slot empty @(HighlightedTeam == Team.Spectator && HighlightedIndex == index ? "drop-target" : "")">Empty</div>
                            }
                        }
                    </div>
                </div>
            </div>
        </div>
    </div>

    @if (IsDragging)
    {
        <div class="dragged-player @GetDraggedTeamClass()" @ref="DraggedElement">
            <img src="avatar:@DraggedSteamId" class="profile-picture" />
            <span class="player-name">@DraggedDisplayName</span>
        </div>
    }
</root>

@code
{
    // ===================================================================================
    // LOBBY CONFIGURATION
    // ===================================================================================

    private TextEntry LobbyNameInput;
    private DropDown PrivacyDropdown;
    private DropDown MaxPlayersDropdown;
    private string DefaultLobbyName => $"{Connection.Local?.DisplayName ?? "Player"}'s Game";
    private bool IsInLobby => NetworkManager.Instance?.CurrentState == NetworkState.InLobby;

    private static List<Option> PrivacyOptions => new()
    {
        new Option( "Public", "Public" ),
        new Option( "Friends Only", "Friends Only" ),
        new Option( "Private", "Private" )
    };

    private static List<Option> MaxPlayersOptions => new()
    {
        new Option( "2", "2" ),
        new Option( "3", "3" ),
        new Option( "4", "4" ),
        new Option( "5", "5" ),
        new Option( "6", "6" ),
        new Option( "7", "7" ),
        new Option( "8", "8" ),
        new Option( "9", "9" ),
        new Option( "10", "10" ),
        new Option( "11", "11" ),
        new Option( "12", "12" )

    };

    private void OnAddFriendClicked()
    {

        var opts = new FriendsListModalOptions();

      


        Game.Overlay.ShowFriendsList( new FriendsListModalOptions() );
    }

    private void OnCreateLobbyClicked()
    {
        var lobbyName = LobbyNameInput?.Text ?? DefaultLobbyName;
        var maxPlayers = int.Parse( MaxPlayersDropdown?.Selected?.Value?.ToString() ?? "4" );
        var privacyValue = PrivacyDropdown?.Selected?.Value?.ToString() ?? "Public";

        var privacy = privacyValue switch
        {
            "Friends Only" => LobbyPrivacy.FriendsOnly,
            "Private" => LobbyPrivacy.Private,
            _ => LobbyPrivacy.Public
        };

        Log.Info( $"[CreateLobby] Creating lobby: {lobbyName}, MaxPlayers: {maxPlayers}, Privacy: {privacy}" );

        NetworkManager.Instance?.CreateLobby( maxPlayers, privacy, lobbyName );

        // Refresh lobby members after creating the lobby
        RefreshLobbyMembers();
        StateHasChanged();
    }

    private void OnStartGameClicked()
    {
        Log.Info( "[CreateLobby] Starting game..." );
        NetworkManager.Instance?.StartGame();
    }

    // ===================================================================================
    // DRAG-AND-DROP PLAYER SLOT SYSTEM
    // ===================================================================================
    //
    // OVERVIEW:
    // Players can be dragged between team slots (Red, Blue, Spectator). Click-hold to
    // pick up a player, drag to a team panel, release to drop into first available slot.
    //
    // KEY DESIGN DECISIONS:
    //
    // 1. SOURCE SLOT STAYS IN DOM (Critical!)
    //    When dragging starts, we DON'T hide the source element. Instead, we mark it with
    //    IsBeingDragged=true and use CSS (.being-dragged) to make it LOOK empty while
    //    keeping it in the DOM. This is essential because removing/hiding the element
    //    that received mousedown breaks the mouse event chain - OnMouseUp would never fire.
    //
    // 2. DROP TARGETS ARE TEAM PANELS, NOT INDIVIDUAL SLOTS
    //    We hit-test against the team panel (@ref="RedTeamPanel" etc), not individual slots.
    //    When dropping on a team, we find the first available slot automatically.
    //    This simplifies the UX - just drag to the team area, don't need pixel-perfect aim.
    //
    // 3. SLOT COMPACTION
    //    After each drop, CompactSlots() shifts all players to fill from index 0.
    //    This prevents gaps (e.g., if you drag out of slot 0, slot 1 becomes slot 0).
    //
    // 4. SOURCE SLOT TREATED AS AVAILABLE
    //    When finding drop targets, FindFirstAvailableSlot() treats the source slot as
    //    empty. This means dragging within the same team targets the source position,
    //    effectively a no-op (player stays in same spot).
    //
    // DRAG FLOW:
    // 1. OnSlotMouseDown: User clicks occupied slot -> IsDragging=true, slot.IsBeingDragged=true
    // 2. Tick: Every frame updates drag position and highlights target slot
    // 3. OnMouseUp: User releases -> EndDrag() moves player data to target, compacts slots
    //
    // VISUAL FEEDBACK:
    // - Source slot: Shows "Empty" via CSS ::after (hides avatar/name with display:none)
    // - Target slot: Gets "drop-target" class for highlight styling
    // - Dragged element: Floating div that follows cursor (transformed to panel coordinates)
    // ===================================================================================

    public enum Team { Red, Blue, Spectator }

    public class PlayerSlot
    {
        public bool IsOccupied { get; set; }
        public long SteamId { get; set; }
        public string DisplayName { get; set; }
        public bool IsBeingDragged { get; set; }
    }

    // Slot data - initialize with empty PlayerSlot objects immediately
    private PlayerSlot[] RedTeamSlots = CreateEmptySlots(5);
    private PlayerSlot[] BlueTeamSlots = CreateEmptySlots(5);
    private PlayerSlot[] SpectatorSlots = CreateEmptySlots(2);
    private bool SlotsInitialized = false;

    // Panel references for hit-testing (team panels, not individual slots)
    private Panel RedTeamPanel;
    private Panel BlueTeamPanel;
    private Panel SpectatorPanel;

    // Drag state
    private bool IsDragging = false;
    private Team DragSourceTeam;
    private int DragSourceIndex;
    private long DraggedSteamId;
    private string DraggedDisplayName;
    private Vector2 DragPosition;
    private Panel DraggedElement;

    // Drop target highlighting
    private Team? HighlightedTeam = null;
    private int? HighlightedIndex = null;

    private static PlayerSlot[] CreateEmptySlots(int count)
    {
        var slots = new PlayerSlot[count];
        for (int i = 0; i < count; i++)
        {
            slots[i] = new PlayerSlot();
        }
        return slots;
    }

    protected override void OnAfterTreeRender(bool firstTime)
    {
        base.OnAfterTreeRender(firstTime);

        if (firstTime && NetworkManager.Instance != null)
        {
            NetworkManager.Instance.OnStateChanged += OnNetworkStateChanged;
            NetworkManager.Instance.OnPlayerJoined += OnPlayerJoined;
            NetworkManager.Instance.OnPlayerLeft += OnPlayerLeft;
        }

        if (!SlotsInitialized)
        {
            InitializeSlots();
            SlotsInitialized = true;
        }

        UpdateDraggedElementPosition();
    }

    public void OnNavigationOpen()
    {
        // Refresh lobby members when opening this page
        if (IsInLobby)
        {
            RefreshLobbyMembers();
        }
    }

    public void OnNavigationClose()
    {
        // Unsubscribe from events when leaving this page
        if (NetworkManager.Instance != null)
        {
            NetworkManager.Instance.OnStateChanged -= OnNetworkStateChanged;
            NetworkManager.Instance.OnPlayerJoined -= OnPlayerJoined;
            NetworkManager.Instance.OnPlayerLeft -= OnPlayerLeft;
        }
    }

    private void OnNetworkStateChanged( NetworkState oldState, NetworkState newState )
    {
        StateHasChanged();
    }

    private void OnPlayerJoined( Connection connection )
    {
        Log.Info( $"[CreateLobby] Player joined: {connection.DisplayName}" );
        RefreshLobbyMembers();
    }

    private void OnPlayerLeft( Connection connection )
    {
        Log.Info( $"[CreateLobby] Player left: {connection.DisplayName}" );
        RefreshLobbyMembers();
    }

    private void InitializeSlots()
    {
        Log.Info("[DragDrop] InitializeSlots called");
        RefreshLobbyMembers();
    }

    private void RefreshLobbyMembers()
    {
        Log.Info("[DragDrop] RefreshLobbyMembers called");

        // Clear all slots first
        foreach (var slot in RedTeamSlots) { slot.IsOccupied = false; slot.SteamId = 0; slot.DisplayName = null; }
        foreach (var slot in BlueTeamSlots) { slot.IsOccupied = false; slot.SteamId = 0; slot.DisplayName = null; }
        foreach (var slot in SpectatorSlots) { slot.IsOccupied = false; slot.SteamId = 0; slot.DisplayName = null; }

        // Get all lobby members from NetworkManager
        var lobbyMembers = NetworkManager.Instance?.LobbyMembers;
        if (lobbyMembers == null || lobbyMembers.Count == 0)
        {
            Log.Info("[DragDrop] No lobby members found");
            StateHasChanged();
            return;
        }

        // Place all lobby members in red team slots by default
        int slotIndex = 0;
        foreach (var member in lobbyMembers)
        {
            if (slotIndex >= RedTeamSlots.Length)
            {
                Log.Info($"[DragDrop] No more red team slots available for {member.DisplayName}");
                break;
            }

            RedTeamSlots[slotIndex].IsOccupied = true;
            RedTeamSlots[slotIndex].SteamId = member.SteamId;
            RedTeamSlots[slotIndex].DisplayName = member.DisplayName;
            Log.Info($"[DragDrop] Placed lobby member: {member.DisplayName} in RedTeamSlots[{slotIndex}]");
            slotIndex++;
        }

        StateHasChanged();
    }

    private void OnSlotMouseDown(Team team, int index)
    {
        Log.Info($"[DragDrop] OnSlotMouseDown called - Team: {team}, Index: {index}");

        var slot = GetSlot(team, index);
        if (slot == null)
        {
            Log.Info("[DragDrop] Slot is null!");
            return;
        }
        if (!slot.IsOccupied)
        {
            Log.Info("[DragDrop] Slot is not occupied!");
            return;
        }

        Log.Info($"[DragDrop] Starting drag for player: {slot.DisplayName}");

        // Start dragging
        IsDragging = true;
        DragSourceTeam = team;
        DragSourceIndex = index;
        DraggedSteamId = slot.SteamId;
        DraggedDisplayName = slot.DisplayName;
        DragPosition = Mouse.Position;

        // Mark source slot as being dragged (shows as empty)
        slot.IsBeingDragged = true;

        StateHasChanged();
        Log.Info("[DragDrop] Drag started, StateHasChanged called");
    }



    public override void Tick()
    {
        base.Tick();

        if (IsDragging)
        {
            // Continuously update position while dragging
            DragPosition = Mouse.Position;
            UpdateDraggedElementPosition();

            // Update drop target highlighting
            var targetTeam = FindTeamUnderMouse();
            var targetIndex = targetTeam.HasValue ? FindFirstAvailableSlot(targetTeam.Value) : null;

            if (HighlightedTeam != targetTeam || HighlightedIndex != targetIndex)
            {
                HighlightedTeam = targetTeam;
                HighlightedIndex = targetIndex;
                StateHasChanged();
            }
        }
    }

    protected override void OnMouseUp(MousePanelEvent e)
    {
        base.OnMouseUp(e);

        if (IsDragging)
        {
            Log.Info("[DragDrop] Mouse released - ending drag");
            EndDrag();
        }
    }

    private void EndDrag()
    {
        var sourceSlot = GetSlot(DragSourceTeam, DragSourceIndex);

        // Find which team panel we're dropping on
        var targetTeam = FindTeamUnderMouse();

        if (targetTeam.HasValue)
        {
            // Find first available slot in the target team
            var targetIndex = FindFirstAvailableSlot(targetTeam.Value);

            if (targetIndex.HasValue)
            {
                // Check if dropping on same team with only one slot occupied (effectively same slot)
                if (targetTeam.Value == DragSourceTeam && targetIndex.Value == DragSourceIndex)
                {
                    Log.Info("[DragDrop] Dropped on same position - no change");
                }
                else
                {
                    var targetSlot = GetSlot(targetTeam.Value, targetIndex.Value);

                    // Drop into the available slot
                    Log.Info($"[DragDrop] Dropping {DraggedDisplayName} into {targetTeam.Value} slot {targetIndex.Value}");

                    targetSlot.IsOccupied = true;
                    targetSlot.SteamId = DraggedSteamId;
                    targetSlot.DisplayName = DraggedDisplayName;

                    // Clear source slot
                    sourceSlot.IsOccupied = false;
                    sourceSlot.SteamId = 0;
                    sourceSlot.DisplayName = null;
                }
            }
            else
            {
                Log.Info($"[DragDrop] No available slots in {targetTeam.Value} - returning to source");
            }
        }
        else
        {
            Log.Info("[DragDrop] Dropped outside valid team panel - returning to source");
        }

        // Always clear the dragging state on source
        if (sourceSlot != null)
        {
            sourceSlot.IsBeingDragged = false;
        }

        // Compact all team slots so they fill from the top
        CompactSlots(RedTeamSlots);
        CompactSlots(BlueTeamSlots);
        CompactSlots(SpectatorSlots);

        IsDragging = false;
        HighlightedTeam = null;
        HighlightedIndex = null;
        StateHasChanged();
    }

    private Team? FindTeamUnderMouse()
    {
        Vector2 mousePos = Mouse.Position;

        if (IsMouseOverPanel(RedTeamPanel, mousePos))
            return Team.Red;

        if (IsMouseOverPanel(BlueTeamPanel, mousePos))
            return Team.Blue;

        if (IsMouseOverPanel(SpectatorPanel, mousePos))
            return Team.Spectator;

        return null;
    }

    private int? FindFirstAvailableSlot(Team team)
    {
        var slots = team switch
        {
            Team.Red => RedTeamSlots,
            Team.Blue => BlueTeamSlots,
            Team.Spectator => SpectatorSlots,
            _ => null
        };

        if (slots == null) return null;

        for (int i = 0; i < slots.Length; i++)
        {
            // Treat slot as available if it's empty OR if it's the source slot being dragged
            bool isSourceSlot = IsDragging && team == DragSourceTeam && i == DragSourceIndex;
            if (!slots[i].IsOccupied || isSourceSlot)
                return i;
        }

        return null; // No available slots
    }

    private void CompactSlots(PlayerSlot[] slots)
    {
        // Move all occupied slots to the front, maintaining order
        int writeIndex = 0;
        for (int readIndex = 0; readIndex < slots.Length; readIndex++)
        {
            if (slots[readIndex].IsOccupied)
            {
                if (writeIndex != readIndex)
                {
                    // Move this slot to the write position
                    slots[writeIndex].IsOccupied = true;
                    slots[writeIndex].SteamId = slots[readIndex].SteamId;
                    slots[writeIndex].DisplayName = slots[readIndex].DisplayName;
                    slots[writeIndex].IsBeingDragged = slots[readIndex].IsBeingDragged;

                    // Clear the old position
                    slots[readIndex].IsOccupied = false;
                    slots[readIndex].SteamId = 0;
                    slots[readIndex].DisplayName = null;
                    slots[readIndex].IsBeingDragged = false;
                }
                writeIndex++;
            }
        }
    }

    private bool IsMouseOverPanel(Panel panel, Vector2 mousePos)
    {
        if (panel == null) return false;

        var rect = panel.Box.Rect;
        return mousePos.x >= rect.Left && mousePos.x <= rect.Right &&
               mousePos.y >= rect.Top && mousePos.y <= rect.Bottom;
    }

    private void UpdateDraggedElementPosition()
    {
        if (DraggedElement == null || !IsDragging) return;

        // Convert screen position to panel space
        Vector2 panelPosition = ScaleFromScreen * DragPosition;

        DraggedElement.Style.Left = Length.Pixels(panelPosition.x);
        DraggedElement.Style.Top = Length.Pixels(panelPosition.y);
    }

    private PlayerSlot GetSlot(Team team, int index)
    {
        return team switch
        {
            Team.Red => index < RedTeamSlots.Length ? RedTeamSlots[index] : null,
            Team.Blue => index < BlueTeamSlots.Length ? BlueTeamSlots[index] : null,
            Team.Spectator => index < SpectatorSlots.Length ? SpectatorSlots[index] : null,
            _ => null
        };
    }

    private string GetDraggedTeamClass()
    {
        return DragSourceTeam switch
        {
            Team.Red => "team-red",
            Team.Blue => "team-blue",
            Team.Spectator => "team-spectator",
            _ => ""
        };
    }

    protected override int BuildHash()
    {
        return System.HashCode.Combine(
            base.BuildHash(),
            IsDragging,
            DragPosition,
            RedTeamSlots[0]?.IsOccupied,
            RedTeamSlots[0]?.IsBeingDragged
        );
    }
}
